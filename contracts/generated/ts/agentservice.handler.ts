// Code generated by dink codegen. DO NOT EDIT.

import type { ServiceHandler, ServiceDefinition } from '@fatagnus/dink-sdk';
import { extractPayload, wrapResponse } from '@fatagnus/dink-sdk';
import type { CreateSessionRequest, CreateSessionResponse, SendMessageRequest, SendMessageResponse, TerminateSessionRequest, TerminateSessionResponse, ListSessionsRequest, ListSessionsResponse, GetEventsRequest, GetEventsResponse, ReplyQuestionRequest, ReplyQuestionResponse, ReplyPermissionRequest, ReplyPermissionResponse } from './types.js';

export interface AgentServiceServer {
  CreateSession(req: CreateSessionRequest): Promise<CreateSessionResponse>;
  SendMessage(req: SendMessageRequest): Promise<SendMessageResponse>;
  TerminateSession(req: TerminateSessionRequest): Promise<TerminateSessionResponse>;
  ListSessions(req: ListSessionsRequest): Promise<ListSessionsResponse>;
  GetEvents(req: GetEventsRequest): Promise<GetEventsResponse>;
  ReplyQuestion(req: ReplyQuestionRequest): Promise<ReplyQuestionResponse>;
  ReplyPermission(req: ReplyPermissionRequest): Promise<ReplyPermissionResponse>;
}

export class AgentServiceHandler implements ServiceHandler {
  private impl: AgentServiceServer;

  constructor(impl: AgentServiceServer) {
    this.impl = impl;
  }

  definition(): ServiceDefinition {
    return {
      name: 'AgentService',
      version: '1.0.0',
      methods: [
        'CreateSession',
        'SendMessage',
        'TerminateSession',
        'ListSessions',
        'GetEvents',
        'ReplyQuestion',
        'ReplyPermission',
      ],
    };
  }

  async handleRequest(method: string, data: Uint8Array): Promise<Uint8Array> {
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const rawReq = data.length > 0 ? JSON.parse(decoder.decode(data)) : {};

    switch (method) {
    case 'CreateSession': {
      const req = extractPayload<CreateSessionRequest>(rawReq);
      const resp = await this.impl.CreateSession(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'SendMessage': {
      const req = extractPayload<SendMessageRequest>(rawReq);
      const resp = await this.impl.SendMessage(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'TerminateSession': {
      const req = extractPayload<TerminateSessionRequest>(rawReq);
      const resp = await this.impl.TerminateSession(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ListSessions': {
      const req = extractPayload<ListSessionsRequest>(rawReq);
      const resp = await this.impl.ListSessions(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'GetEvents': {
      const req = extractPayload<GetEventsRequest>(rawReq);
      const resp = await this.impl.GetEvents(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ReplyQuestion': {
      const req = extractPayload<ReplyQuestionRequest>(rawReq);
      const resp = await this.impl.ReplyQuestion(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ReplyPermission': {
      const req = extractPayload<ReplyPermissionRequest>(rawReq);
      const resp = await this.impl.ReplyPermission(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    default:
      throw new Error(`Unknown method: ${method}`);
    }
  }

  async handleStream(method: string, data: Uint8Array, emit: (data: Uint8Array) => Promise<void>): Promise<void> {
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const rawReq = data.length > 0 ? JSON.parse(decoder.decode(data)) : {};

    const stream = {
      send: async (msg: unknown) => {
        await emit(encoder.encode(JSON.stringify(wrapResponse(msg))));
      },
    };

    switch (method) {
    default:
      throw new Error(`Unknown streaming method: ${method}`);
    }
  }
}
