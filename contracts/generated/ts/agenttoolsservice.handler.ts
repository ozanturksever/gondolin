// Code generated by dink codegen. DO NOT EDIT.

import type { ServiceHandler, ServiceDefinition } from '@fatagnus/dink-sdk';
import { extractPayload, wrapResponse } from '@fatagnus/dink-sdk';
import type { ExecCommandRequest, ExecCommandResponse, ReadFileRequest, ReadFileResponse, WriteFileRequest, WriteFileResponse, DeleteFileRequest, DeleteFileResponse, ListFilesRequest, ListFilesResponse, SearchCodebaseRequest, SearchCodebaseResponse, RunTestsRequest, RunTestsResponse, InstallPackageRequest, InstallPackageResponse, ExportPatchRequest, ExportPatchResponse } from './types.js';

export interface AgentToolsServiceServer {
  ExecCommand(req: ExecCommandRequest): Promise<ExecCommandResponse>;
  ReadFile(req: ReadFileRequest): Promise<ReadFileResponse>;
  WriteFile(req: WriteFileRequest): Promise<WriteFileResponse>;
  DeleteFile(req: DeleteFileRequest): Promise<DeleteFileResponse>;
  ListFiles(req: ListFilesRequest): Promise<ListFilesResponse>;
  SearchCodebase(req: SearchCodebaseRequest): Promise<SearchCodebaseResponse>;
  RunTests(req: RunTestsRequest): Promise<RunTestsResponse>;
  InstallPackage(req: InstallPackageRequest): Promise<InstallPackageResponse>;
  ExportPatch(req: ExportPatchRequest): Promise<ExportPatchResponse>;
}

export class AgentToolsServiceHandler implements ServiceHandler {
  private impl: AgentToolsServiceServer;

  constructor(impl: AgentToolsServiceServer) {
    this.impl = impl;
  }

  definition(): ServiceDefinition {
    return {
      name: 'AgentToolsService',
      version: '1.0.0',
      methods: [
        'ExecCommand',
        'ReadFile',
        'WriteFile',
        'DeleteFile',
        'ListFiles',
        'SearchCodebase',
        'RunTests',
        'InstallPackage',
        'ExportPatch',
      ],
    };
  }

  async handleRequest(method: string, data: Uint8Array): Promise<Uint8Array> {
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const rawReq = data.length > 0 ? JSON.parse(decoder.decode(data)) : {};

    switch (method) {
    case 'ExecCommand': {
      const req = extractPayload<ExecCommandRequest>(rawReq);
      const resp = await this.impl.ExecCommand(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ReadFile': {
      const req = extractPayload<ReadFileRequest>(rawReq);
      const resp = await this.impl.ReadFile(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'WriteFile': {
      const req = extractPayload<WriteFileRequest>(rawReq);
      const resp = await this.impl.WriteFile(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'DeleteFile': {
      const req = extractPayload<DeleteFileRequest>(rawReq);
      const resp = await this.impl.DeleteFile(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ListFiles': {
      const req = extractPayload<ListFilesRequest>(rawReq);
      const resp = await this.impl.ListFiles(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'SearchCodebase': {
      const req = extractPayload<SearchCodebaseRequest>(rawReq);
      const resp = await this.impl.SearchCodebase(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'RunTests': {
      const req = extractPayload<RunTestsRequest>(rawReq);
      const resp = await this.impl.RunTests(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'InstallPackage': {
      const req = extractPayload<InstallPackageRequest>(rawReq);
      const resp = await this.impl.InstallPackage(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    case 'ExportPatch': {
      const req = extractPayload<ExportPatchRequest>(rawReq);
      const resp = await this.impl.ExportPatch(req);
      return encoder.encode(JSON.stringify(wrapResponse(resp)));
    }
    default:
      throw new Error(`Unknown method: ${method}`);
    }
  }

  async handleStream(method: string, data: Uint8Array, emit: (data: Uint8Array) => Promise<void>): Promise<void> {
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const rawReq = data.length > 0 ? JSON.parse(decoder.decode(data)) : {};

    const stream = {
      send: async (msg: unknown) => {
        await emit(encoder.encode(JSON.stringify(wrapResponse(msg))));
      },
    };

    switch (method) {
    default:
      throw new Error(`Unknown streaming method: ${method}`);
    }
  }
}
